---
author: 小莫
date: 2018-05-31
title: jdk源码阅读-Object
tags:
- jdk源码阅读
category: jdk源码阅读
permalink: jdkSourceCodeReadObject
---
Object类是类层次结构的根，是每一个类的父类。所有的对象（包括数组）都是实现了object类的方法。
<!-- more -->

Object结构
![](https://image.xiaomo.info/blog/ObjectStructure.png)

这里有7个native方法：

- registerNatives()
- getClass()
- hashCode()
- clone()
- notify()
- notifyAll()
- wait(long)

什么是native方法？简单的说，native表示该方法的实现java本身并没有完成，而是有c/c++来完成，放在.dll动态库文件中。这里我们不关注本地方法的具体，我们可以看看其注释和声明，知道这些方法是干什么的。

### 1）`registerNatives()`

```
 private static native void registerNatives();
 static {
     registerNatives();
 }
```
 
该方法源码中并没有任何注释说明，而且在静态块中调用了方法。首先明确在类初始化的时候，这个方法被调用执行了。
至于该方法的做用，请看native方法的c代码实现：这里是相关的C代码（来自OpenJDK6）：

```
static JNINativeMethod methods[] = {

　　{“hashCode”, “()I”, (void *)&JVM_IHashCode},

　　{“wait”, “(J)V”, (void *)&JVM_MonitorWait},

　　{“notify”, “()V”, (void *)&JVM_MonitorNotify},

　　{“notifyAll”, “()V”, (void *)&JVM_MonitorNotifyAll},

　　{“clone”, “()Ljava/lang/Object;”, (void *)&JVM_Clone},

};

JNIEXPORT void JNICALL

Java_java_lang_Object_registerNatives(JNIEnv *env, jclass cls)
{
　　(*env)->RegisterNatives(env, cls,methods, sizeof(methods)/sizeof(methods[0]));
}
```

详细的说：通常情况下，为了使JVM发现您的本机功能，他们被一定的方式命名。例如，对于java.lang.Object.registerNatives，对应的C函数命名为Java_java_lang_Object_registerNatives。通过使用registerNatives（或者更确切地说，JNI函数RegisterNatives），您可以命名任何你想要你的C函数。(来自：[https://www.linuxidc.com/Linux/2015-06/118676.htm](https://www.linuxidc.com/Linux/2015-06/118676.htm))
简单的说：就是对几个本地方法进行注册(也就是初始化java方法映射到C的方法)。
细心的读者可能发现这里为什么没有getClass()方法的注册？因为它不需要被注册，它有一个Java_java_lang_Object_getClass的“标准”名称。